<!-- Save this as index.html and serve it -->
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Zuckabot â€” Claim Portal (Live)</title>
<style>
  :root{
    --primary:#00ff00; --bg:#0a0a0a; --card:#111; --text:#fff; --muted:#aaa; --accent:#ff9900; --danger:#ff4444; --success:#00C851;
  }
  body{font-family:Arial,Helvetica,sans-serif;background:var(--bg);color:var(--text);margin:0;padding:1rem;text-align:center;}
  h1,h2,h3{color:var(--primary);margin:0.4rem 0;}
  .card{background:var(--card);border-radius:8px;padding:1.25rem;margin:1rem auto;max-width:900px;box-shadow:0 6px 18px rgba(0,0,0,.5);text-align:left;}
  button{padding:10px 16px;border-radius:8px;border:none;cursor:pointer;font-weight:700;margin:6px;}
  .connect{background:var(--accent);color:#000;}
  .primary{background:var(--primary);color:#000;}
  .secondary{background:#222;color:var(--text);}
  .small{font-size:0.9rem;color:var(--muted);}
  .inline{display:flex;justify-content:space-between;align-items:center;gap:12px;flex-wrap:wrap;}
  input{padding:8px;border-radius:6px;border:1px solid #333;background:#111;color:var(--text);}
  .notification{position:fixed;right:20px;top:20px;padding:12px 14px;border-radius:8px;display:none;z-index:9999;}
  .notification.success{background:var(--success);color:#000;}
  .notification.error{background:var(--danger);color:#fff;}
  .address{font-family:monospace;font-size:13px;word-break:break-all;}
  a.link{color:var(--primary);text-decoration:none;}
  footer{color:var(--muted);text-align:center;margin-top:1rem;}
  @media(max-width:600px){ .inline{flex-direction:column;align-items:flex-start;} button{width:100%;} }
</style>
</head>
<body>
<div id="notification" class="notification"></div>

<h1>Zuckabot</h1>
<h3>Claim Portal â€” Pre-Launch Giveaway</h3>
<p class="small">2-step: <strong>Initiate</strong> â†’ wait ~10 minutes â†’ <strong>Finalize</strong> with small on-chain fee. The UI reads Chainlink via the contract so amounts match on-chain.</p>

<!-- Connect -->
<div class="card">
  <div class="inline">
    <div>
      <h3>Connect Wallet</h3>
      <p id="walletInfo" class="small">Not connected</p>
    </div>
    <div>
      <button id="connectButton" class="connect">Connect Wallet</button>
      <button onclick="addToken()" class="secondary">Add ZUCKA to Wallet</button>
    </div>
  </div>
  <p class="small">Tip: Best experience in Trust Wallet / MetaMask app browser.</p>
</div>

<!-- Tasks (client-side) -->
<div class="card">
  <h3>Complete Social Tasks</h3>
  <p class="small">Help Zuckabot go viral: join, follow, share, then paste proof links. Stored locally only.</p>

  <div class="task inline">
    <div>
      Telegram <span id="telegramStatus" class="small" style="margin-left:8px;color:var(--muted)">Pending</span><br/>
      <a class="link" href="https://t.me/zuckabotofficial/1" target="_blank">Join Telegram</a>
    </div>
    <div style="flex:1">
      <input id="telegramProof" placeholder="Paste proof link (Telegram)" />
      <button onclick="verifyTask('telegram')" class="secondary">Verify</button>
      <span id="checkTelegram" style="display:none">âœ…</span>
    </div>
  </div>

  <div class="task inline" style="margin-top:8px">
    <div>
      X (Twitter) <span id="xStatus" class="small" style="margin-left:8px;color:var(--muted)">Pending</span><br/>
      <a class="link" href="https://x.com/zuckabottoken" target="_blank">Follow on X</a>
    </div>
    <div style="flex:1">
      <input id="xProof" placeholder="Paste proof link (X)" />
      <button onclick="verifyTask('x')" class="secondary">Verify</button>
      <span id="checkX" style="display:none">âœ…</span>
    </div>
  </div>

  <div class="task inline" style="margin-top:8px">
    <div>
      Facebook <span id="facebookStatus" class="small" style="margin-left:8px;color:var(--muted)">Pending</span><br/>
      <a class="link" href="https://web.facebook.com/profile.php?id=61579580776149" target="_blank">Like on Facebook</a>
    </div>
    <div style="flex:1">
      <input id="facebookProof" placeholder="Paste proof link (Facebook)" />
      <button onclick="verifyTask('facebook')" class="secondary">Verify</button>
      <span id="checkFB" style="display:none">âœ…</span>
    </div>
  </div>
  <p class="small">Status: ðŸ”´ Pending â†’ ðŸŸ¡ Submitted â†’ ðŸŸ¢ Verified (auto after 10 min).</p>
</div>

<!-- Claim card -->
<div class="card">
  <h3>Claim Your ZUCKA</h3>
  <p class="small">2-step claim: initiate â†’ wait ~10 minutes â†’ finalize (sends required BNB to treasury).</p>

  <div class="inline" style="margin-top:6px;">
    <div>
      <p>BNB Price (Chainlink): <strong id="bnbPrice">$--</strong></p>
      <p>Claim Fee: <strong id="claimFee">-- BNB</strong></p>
    </div>
    <div>
      <button id="initiateBtn" class="primary" disabled>Initiate Claim</button>
      <button id="finalizeBtn" class="secondary" disabled>Finalize Claim</button>
    </div>
  </div>

  <p id="claimStatus" class="small">Status: Not started</p>
  <p id="claimTimer" class="small">Time remaining: --:--</p>
  <p class="small">Your claim amount: <strong>1,500 ZUCKA</strong></p>
</div>

<!-- Stats card -->
<div class="card">
  <h3>On-chain Stats</h3>
  <p class="small">Distributor token balance: <strong id="distTokenBalance">--</strong></p>
  <p class="small">Total Claimed Tokens: <strong id="totalClaimed">--</strong></p>
  <p class="small">Total Donations (BNB forwarded): <strong id="totalDonatedBNB">--</strong></p>
  <p class="small">Distributor: <span class="address">0xec222Dba73C17877773E411D15904bf205FbA149</span>
    &nbsp; <a id="distributorLink" class="link" href="#" target="_blank">View on BSCScan</a></p>
  <p class="small">Token: <span class="address">0x54bff3901d7d27ffe21b9a23bc8efb48c9847048</span>
    &nbsp; <a id="tokenLink" class="link" href="#" target="_blank">View on BSCScan</a></p>
</div>

<footer class="small">
  Â©2025 Zuckabot â€¢ Distributor: 0xec222Dba73C17877773E411D15904bf205FbA149 â€¢ Treasury: 0x42e8D84Ff8ff8e5EaE8E2648Ebfa772ee4515c91
</footer>

<!-- ethers v5 -->
<script src="https://cdn.jsdelivr.net/npm/ethers@5.7.2/dist/ethers.min.js"></script>
<script>
(() => {
  // ---------- Config (from user)
  const TOKEN_ADDR = '0x54bff3901d7d27ffe21b9a23bc8efb48c9847048';
  const DISTRIBUTOR_ADDR = '0xec222Dba73C17877773E411D15904bf205FbA149';
  const TREASURY_ADDR = '0x42e8D84Ff8ff8e5EaE8E2648Ebfa772ee4515c91';
  const BSCSCAN_BASE = 'https://bscscan.com';

  // Full ABIs (from user)
  const tokenAbi = [{"inputs":[],"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"owner","type":"address"},{"indexed":true,"internalType":"address","name":"spender","type":"address"},{"indexed":false,"internalType":"uint256","name":"value","type":"uint256"}],"name":"Approval","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"previousOwner","type":"address"},{"indexed":true,"internalType":"address","name":"newOwner","type":"address"}],"name":"OwnershipTransferred","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"from","type":"address"},{"indexed":true,"internalType":"address","name":"to","type":"address"},{"indexed":false,"internalType":"uint256","name":"value","type":"uint256"}],"name":"Transfer","type":"event"},{"inputs":[{"internalType":"address","name":"owner","type":"address"},{"internalType":"address","name":"spender","type":"address"}],"name":"allowance","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"spender","type":"address"},{"internalType":"uint256","name":"amount","type":"uint256"}],"name":"approve","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"account","type":"address"}],"name":"balanceOf","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"decimals","outputs":[{"internalType":"uint8","name":"","type":"uint8"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"name","outputs":[{"internalType":"string","name":"","type":"string"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"owner","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"renounceOwnership","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"symbol","outputs":[{"internalType":"string","name":"","type":"string"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"totalSupply","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"to","type":"address"},{"internalType":"uint256","name":"amount","type":"uint256"}],"name":"transfer","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"from","type":"address"},{"internalType":"address","name":"to","type":"address"},{"internalType":"uint256","name":"amount","type":"uint256"}],"name":"transferFrom","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"nonpayable","type":"function"}];

  const distributorAbi = [{"inputs":[{"internalType":"address","name":"_zuckaToken","type":"address"},{"internalType":"address","name":"_priceFeed","type":"address"}],"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"user","type":"address"},{"indexed":false,"internalType":"uint256","name":"zuckaAmount","type":"uint256"},{"indexed":false,"internalType":"uint256","name":"bnbPaid","type":"uint256"}],"name":"ClaimFinalized","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"user","type":"address"},{"indexed":false,"internalType":"uint256","name":"timestamp","type":"uint256"}],"name":"ClaimInitiated","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"user","type":"address"},{"indexed":false,"internalType":"uint256","name":"bnbAmount","type":"uint256"},{"indexed":false,"internalType":"uint256","name":"zuckaAmount","type":"uint256"}],"name":"Donated","type":"event"},{"inputs":[],"name":"BASE_RATE_PER_USD18","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"CLAIM_AMOUNT","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"CLAIM_FEE_USD18","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"TREASURY","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"donate","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[],"name":"finalizeClaim","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[],"name":"getLatestBNBPrice18","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"getTotals","outputs":[{"internalType":"uint256","name":"tokensDistributed","type":"uint256"},{"internalType":"uint256","name":"bnbCollectedWei","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"","type":"address"}],"name":"hasClaimed","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"initiateClaim","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"","type":"address"}],"name":"pendingClaimTimestamp","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"priceFeed","outputs":[{"internalType":"contract AggregatorV3Interface","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"requiredClaimWei","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"user","type":"address"}],"name":"secondsUntilFinalize","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"totalClaimedTokens","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"totalDonatedBNB","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"usd18","type":"uint256"}],"name":"usd18ToWei","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"weiAmount","type":"uint256"}],"name":"weiToUsd18","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"zucka","outputs":[{"internalType":"contract IERC20","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"stateMutability":"payable","type":"receive"}];

  // Read-only provider (BSC)
  const readProvider = new ethers.providers.JsonRpcProvider('https://bsc-dataseed.binance.org/');

  const distributorRead = new ethers.Contract(DISTRIBUTOR_ADDR, distributorAbi, readProvider);
  const tokenRead = new ethers.Contract(TOKEN_ADDR, tokenAbi, readProvider);

  // UI elements
  const notifyEl = document.getElementById('notification');
  const connectButton = document.getElementById('connectButton');
  const walletInfo = document.getElementById('walletInfo');
  const initiateBtn = document.getElementById('initiateBtn');
  const finalizeBtn = document.getElementById('finalizeBtn');
  const bnbPriceEl = document.getElementById('bnbPrice');
  const claimFeeEl = document.getElementById('claimFee');
  const distTokenBalanceEl = document.getElementById('distTokenBalance');
  const totalClaimedEl = document.getElementById('totalClaimed');
  const totalDonatedEl = document.getElementById('totalDonatedBNB');
  const distributorLink = document.getElementById('distributorLink');
  const tokenLink = document.getElementById('tokenLink');
  const claimStatusEl = document.getElementById('claimStatus');
  const claimTimerEl = document.getElementById('claimTimer');

  distributorLink.href = `${BSCSCAN_BASE}/address/${DISTRIBUTOR_ADDR}`;
  tokenLink.href = `${BSCSCAN_BASE}/address/${TOKEN_ADDR}`;

  // Wallet signer contract handles (set on connect)
  let provider = null;
  let signer = null;
  let distributor = null;
  let token = null;
  let userAddress = null;

  // tasks local storage
  let tasks = {telegram:{verified:false}, x:{verified:false}, facebook:{verified:false}};
  try { const saved = JSON.parse(localStorage.getItem('zuckabotData')||'{}'); if (saved.tasks) tasks = saved.tasks; } catch(e){}

  // notify
  function notify(msg, type='success', t=3500){
    notifyEl.textContent = msg;
    notifyEl.className = `notification ${type==='error'?'error':'success'}`;
    notifyEl.style.display = 'block';
    setTimeout(()=>{ notifyEl.style.display='none'; }, t);
  }

  // format big numbers with decimals
  async function formatTokenAmount(raw, decimals) {
    try { return Number(ethers.utils.formatUnits(raw, decimals)).toLocaleString(undefined, {maximumFractionDigits: 6}); }
    catch(e){ return raw.toString(); }
  }

  // fetch on-chain stats (read-only)
  async function refreshReadOnlyData(){
    try {
      // Chainlink price scaled to 1e18
      const price18 = await distributorRead.getLatestBNBPrice18();
      const priceUsd = Number(ethers.utils.formatUnits(price18, 18));
      bnbPriceEl.textContent = `$${priceUsd.toFixed(2)}`;

      // claim fee in wei -> display BNB
      const requiredWei = await distributorRead.requiredClaimWei();
      const requiredBNB = ethers.utils.formatEther(requiredWei);
      claimFeeEl.textContent = Number(requiredBNB).toString();

      // totals
      const totalClaimed = await distributorRead.totalClaimedTokens();
      const totalDonatedWei = await distributorRead.totalDonatedBNB();

      // token decimals & symbol
      const decimals = await tokenRead.decimals();
      const symbol = await tokenRead.symbol();

      // distributor token balance
      const distBalRaw = await tokenRead.balanceOf(DISTRIBUTOR_ADDR);
      distTokenBalanceEl.textContent = (await formatTokenAmount(distBalRaw, decimals)) + ` ${symbol}`;

      totalClaimedEl.textContent = (await formatTokenAmount(totalClaimed, decimals)) + ` ${symbol}`;
      totalDonatedEl.textContent = (Number(ethers.utils.formatEther(totalDonatedWei))).toFixed(6) + ' BNB';
    } catch(err){
      console.error('read-only refresh failed', err);
      bnbPriceEl.textContent = 'Unavailable';
      claimFeeEl.textContent = '--';
      distTokenBalanceEl.textContent = '--';
      totalClaimedEl.textContent = '--';
      totalDonatedEl.textContent = '--';
    }
  }

  // connect wallet & signer
  async function connectWallet(){
    if (!window.ethereum){ notify('No wallet found â€” install MetaMask or use Trust Wallet in-app browser', 'error'); return; }
    try {
      // request accounts
      await window.ethereum.request({ method: 'eth_requestAccounts' });
      provider = new ethers.providers.Web3Provider(window.ethereum, 'any');
      signer = provider.getSigner();
      userAddress = await signer.getAddress();

      // network check + auto-switch
      const net = await provider.getNetwork();
      if (net.chainId !== 56) {
        // try to switch the network in wallet
        try {
          await window.ethereum.request({ method: 'wallet_switchEthereumChain', params: [{ chainId: '0x38' }] });
          notify('Switched wallet to BSC Mainnet');
        } catch (switchErr) {
          // If the chain is not added, request to add it
          if (switchErr.code === 4902 || (switchErr.data && switchErr.data.originalError && switchErr.data.originalError.code === 4902)) {
            try {
              await window.ethereum.request({
                method: 'wallet_addEthereumChain',
                params: [{
                  chainId: '0x38',
                  chainName: 'BSC Mainnet',
                  nativeCurrency: { name: 'BNB', symbol: 'BNB', decimals: 18 },
                  rpcUrls: ['https://bsc-dataseed.binance.org/'],
                  blockExplorerUrls: ['https://bscscan.com']
                }]
              });
              notify('BSC added to wallet â€” please switch to it.');
            } catch(addErr) {
              console.error('add chain failed', addErr);
              notify('Please switch your wallet to BSC (Mainnet)', 'error', 5000);
            }
          } else {
            notify('Please switch your wallet to BSC (Mainnet)', 'error', 5000);
          }
        }
      }

      // re-init provider & signer in case net changed
      provider = new ethers.providers.Web3Provider(window.ethereum, 'any');
      signer = provider.getSigner();

      distributor = new ethers.Contract(DISTRIBUTOR_ADDR, distributorAbi, signer);
      token = new ethers.Contract(TOKEN_ADDR, tokenAbi, signer);

      walletInfo.textContent = `Connected: ${userAddress.substring(0,6)}...${userAddress.slice(-4)}`;
      notify('Wallet connected');

      // wire listener
      window.ethereum.on('accountsChanged', handleAccountsChanged);
      window.ethereum.on('chainChanged', () => { location.reload(); });

      // refresh everything both read-only and user-specific
      await refreshReadOnlyData();
      await refreshUserState();

      // enable/disable buttons based on tasks + state
      updateButtons();
    } catch(err){
      console.error('connect failed', err);
      notify('Connection failed: ' + (err && err.message ? err.message : err), 'error', 4000);
    }
  }

  connectButton.addEventListener('click', connectWallet);

  function handleAccountsChanged(accounts){
    if (!accounts || accounts.length === 0) {
      walletInfo.textContent = 'Not connected';
      notify('Wallet disconnected', 'error');
      userAddress = null;
      distributor = null;
      token = null;
      updateButtons();
    } else {
      userAddress = accounts[0];
      walletInfo.textContent = `Connected: ${userAddress.substring(0,6)}...${userAddress.slice(-4)}`;
      refreshUserState();
      updateButtons();
    }
  }

  // add token to wallet
  async function addToken(){
    if (!window.ethereum){ notify('No wallet found', 'error'); return; }
    try {
      await window.ethereum.request({
        method: 'wallet_watchAsset',
        params: {
          type: 'ERC20',
          options: { address: TOKEN_ADDR, symbol: 'ZUCKA', decimals: 18, image: 'https://zuckabot.com/icon.png' }
        }
      });
      notify('Token add requested');
    } catch(e){ console.error(e); notify('Failed to add token', 'error'); }
  }

  // tasks verification (client-side)
  function verifyTask(task){
    const el = document.getElementById(task + 'Proof');
    if (!el) {
      notify('Proof input missing', 'error'); return;
    }
    const val = el.value.trim();
    if (!val){ notify('Paste a proof link before verifying', 'error'); return; }
    try { new URL(val); } catch(e){ notify('Invalid URL', 'error'); return; }

    tasks[task] = { verified: true, timestamp: Date.now() };
    document.getElementById('check'+task.charAt(0).toUpperCase()+task.slice(1)).style.display = 'inline';
    document.getElementById(task+'Status').textContent = 'Submitted';
    notify('Task submitted; it will auto-verify in 10 minutes');

    setTimeout(() => {
      document.getElementById(task+'Status').textContent = 'Verified';
      document.getElementById('check'+task.charAt(0).toUpperCase()+task.slice(1)).style.display = 'inline';
      tasks[task].verified = true;
      notify(`${task} verified`, 'success');
      saveLocal();
      updateButtons();
    }, 600000);

    saveLocal();
    updateButtons();
  }

  function saveLocal(){ localStorage.setItem('zuckabotData', JSON.stringify({tasks})); }

  // refresh user-specific on-chain state
  async function refreshUserState(){
    if (!distributor || !userAddress) return;
    try {
      const hasClaimed = await distributor.hasClaimed(userAddress);
      const pending = await distributor.pendingClaimTimestamp(userAddress);
      const secondsLeft = await distributor.secondsUntilFinalize(userAddress);

      if (hasClaimed) {
        claimStatusEl.textContent = 'Status: Already claimed';
        initiateBtn.disabled = true;
        finalizeBtn.disabled = true;
      } else if (pending && pending.toNumber() !== 0) {
        if (secondsLeft.toNumber() === 0) {
          claimStatusEl.textContent = 'Status: Ready to finalize';
          initiateBtn.disabled = true;
          finalizeBtn.disabled = false;
          startCountdown(0);
        } else {
          claimStatusEl.textContent = 'Status: Waiting verification (10m)';
          initiateBtn.disabled = true;
          finalizeBtn.disabled = true;
          startCountdown(secondsLeft.toNumber());
        }
      } else {
        claimStatusEl.textContent = 'Status: Not started';
        initiateBtn.disabled = false;
        finalizeBtn.disabled = true;
      }
    } catch(err) {
      console.error('refreshUserState', err);
      claimStatusEl.textContent = 'Status: Unknown';
    }
  }

  // countdown UI
  let countdownInterval = null;
  function startCountdown(seconds){
    clearInterval(countdownInterval);
    if (seconds === 0) { claimTimerEl.textContent = 'Ready to finalize!'; finalizeBtn.disabled = false; return; }
    let remaining = seconds;
    claimTimerEl.textContent = `Time remaining: ${formatRemaining(remaining)}`;
    countdownInterval = setInterval(() => {
      remaining = Math.max(0, remaining - 1);
      claimTimerEl.textContent = `Time remaining: ${formatRemaining(remaining)}`;
      if (remaining === 0) { clearInterval(countdownInterval); claimTimerEl.textContent = 'Ready to finalize!'; finalizeBtn.disabled = false; notify('Your claim is ready to finalize', 'success'); }
    }, 1000);
  }
  function formatRemaining(sec){ const m=Math.floor(sec/60); const s=sec%60; return `${m}:${s.toString().padStart(2,'0')}`; }

  // enable/disable buttons based on tasks and wallet state
  function updateButtons(){
    const allTasks = tasks.telegram && tasks.x && tasks.facebook && tasks.telegram.verified && tasks.x.verified && tasks.facebook.verified;
    initiateBtn.disabled = !(allTasks && !!userAddress && !!distributor);
  }

  // Initiate claim (signed tx)
  initiateBtn.addEventListener('click', async () => {
    if (!distributor) { notify('Wallet not connected', 'error'); return; }
    try {
      initiateBtn.disabled = true;
      notify('Sending initiateClaim() transaction...');
      const tx = await distributor.initiateClaim();
      const rcpt = await tx.wait();
      notify(`initiateClaim tx sent. Hash: ${rcpt.transactionHash}`, 'success', 6000);
      // show bscscan link
      window.open(`${BSCSCAN_BASE}/tx/${rcpt.transactionHash}`, '_blank');
      await refreshUserState();
    } catch(err){
      console.error('initiateClaim failed', err);
      notify('initiateClaim failed: ' + (err && err.message ? err.message : err), 'error', 6000);
      initiateBtn.disabled = false;
    }
  });

  // Finalize claim (send required wei)
  finalizeBtn.addEventListener('click', async () => {
    if (!distributor) { notify('Wallet not connected', 'error'); return; }
    try {
      finalizeBtn.disabled = true;
      notify('Fetching required fee...');
      // ensure we use signer to read (same chain)
      const requiredWei = await distributor.requiredClaimWei();
      notify(`Sending finalizeClaim() with value ${ethers.utils.formatEther(requiredWei)} BNB`);
      const tx = await distributor.finalizeClaim({ value: requiredWei });
      const rcpt = await tx.wait();
      notify(`Claim finalized! Tx: ${rcpt.transactionHash}`, 'success', 7000);
      window.open(`${BSCSCAN_BASE}/tx/${rcpt.transactionHash}`, '_blank');
      // refresh read & user state
      await refreshReadOnlyData();
      await refreshUserState();
    } catch(err){
      console.error('finalizeClaim failed', err);
      notify('finalizeClaim failed: ' + (err && err.message ? err.message : err), 'error', 6000);
      finalizeBtn.disabled = false;
    }
  });

  // initial bootstrap
  (async function init(){
    // load tasks local state into UI
    try {
      if (tasks.telegram && tasks.telegram.verified) { document.getElementById('checkTelegram').style.display='inline'; document.getElementById('telegramStatus').textContent='Verified'; }
      if (tasks.x && tasks.x.verified) { document.getElementById('checkX').style.display='inline'; document.getElementById('xStatus').textContent='Verified'; }
      if (tasks.facebook && tasks.facebook.verified) { document.getElementById('checkFB').style.display='inline'; document.getElementById('facebookStatus').textContent='Verified'; }
    } catch(e){}

    // fetch read-only chain data once
    await refreshReadOnlyData();
    // refresh every 30s
    setInterval(refreshReadOnlyData, 30000);

    // attempt to enable buttons state (may be disabled until wallet)
    updateButtons();
  })();

})();
</script>
</body>
</html>
